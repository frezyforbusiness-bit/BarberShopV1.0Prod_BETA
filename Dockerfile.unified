# Dockerfile Unificato - Backend + Frontend in un unico servizio
# Usa nginx per servire il frontend e fare proxy al backend

# ============================================
# Stage 1: Build Frontend
# ============================================
FROM node:20-bullseye AS frontend-builder

WORKDIR /app/frontend

# Installa dipendenze di sistema se necessarie
RUN apt-get update && apt-get install -y \
    python3 \
    make \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# Copia package files dal frontend
COPY frontend/package*.json ./

# Installa dipendenze
RUN if [ -f package-lock.json ]; then npm ci --legacy-peer-deps; else npm install --legacy-peer-deps; fi

# Copia tutto il codice frontend
COPY frontend/ ./

# Build dell'applicazione frontend
RUN npm run build

# ============================================
# Stage 2: Build Backend
# ============================================
FROM node:20-bullseye AS backend-builder

WORKDIR /app/backend

# Installa OpenSSL e librerie necessarie per Prisma
RUN apt-get update && apt-get install -y \
    openssl \
    libssl1.1 \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

# Copia package files dal backend
COPY backend/package*.json ./
COPY backend/package-lock.json* ./

# Installa dipendenze
RUN if [ -f package-lock.json ]; then npm ci; else npm install; fi

# Copia schema Prisma (necessario per generare il client)
COPY backend/prisma ./prisma/

# Copia tutto il codice backend
COPY backend/ ./

# Genera Prisma Client e build dell'applicazione
RUN npx prisma generate && npm run build

# ============================================
# Stage 3: Production - Nginx + Backend
# ============================================
FROM node:20-bullseye

WORKDIR /app

# Installa OpenSSL e librerie necessarie per Prisma
RUN apt-get update && apt-get install -y \
    openssl \
    libssl1.1 \
    ca-certificates \
    nginx \
    netcat-openbsd \
    && rm -rf /var/lib/apt/lists/*

# Copia backend buildato
COPY --from=backend-builder /app/backend/dist ./backend/dist
COPY --from=backend-builder /app/backend/node_modules ./backend/node_modules
COPY --from=backend-builder /app/backend/package.json ./backend/package.json
COPY --from=backend-builder /app/backend/prisma ./backend/prisma

# Copia frontend buildato
COPY --from=frontend-builder /app/frontend/dist /usr/share/nginx/html

# Verifica che i file frontend esistano
RUN ls -la /usr/share/nginx/html/ && \
    test -f /usr/share/nginx/html/index.html && \
    echo "✅ Frontend files copied successfully" || \
    (echo "❌ Frontend index.html not found!" && exit 1)

# Script di avvio che avvia sia backend che nginx
RUN echo '#!/bin/bash\n\
set -e\n\
\n\
# Funzione per gestire la terminazione\n\
cleanup() {\n\
    echo "Shutting down..."\n\
    kill -TERM "$BACKEND_PID" 2>/dev/null || true\n\
    nginx -s quit 2>/dev/null || true\n\
    exit 0\n\
}\n\
\n\
trap cleanup SIGTERM SIGINT\n\
\n\
# Porta del backend (fissa interna, NON usa PORT di Railway)\n\
BACKEND_PORT=3001\n\
# Porta di nginx (usa PORT se impostato da Railway, altrimenti 80)\n\
NGINX_PORT=${PORT:-80}\n\
\n\
echo "Configuration:"\n\
echo "  Backend port: $BACKEND_PORT"\n\
echo "  Nginx port: $NGINX_PORT"\n\
\n\
# Genera configurazione nginx dinamicamente\n\
cat > /etc/nginx/conf.d/default.conf <<NGINX_CONF\n\
server {\n\
    listen $NGINX_PORT default_server;\n\
    server_name _;\n\
    root /usr/share/nginx/html;\n\
    index index.html;\n\
    \n\
    # Proxy per API backend - deve essere prima della location /\n\
    location /api {\n\
        proxy_pass http://127.0.0.1:$BACKEND_PORT;\n\
        proxy_http_version 1.1;\n\
        proxy_set_header Upgrade \$http_upgrade;\n\
        proxy_set_header Connection "upgrade";\n\
        proxy_set_header Host \$host;\n\
        proxy_set_header X-Real-IP \$remote_addr;\n\
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;\n\
        proxy_set_header X-Forwarded-Proto \$scheme;\n\
    }\n\
    \n\
    # Serve file statici del frontend\n\
    location / {\n\
        try_files \$uri \$uri/ /index.html;\n\
        add_header Cache-Control "no-cache";\n\
    }\n\
}\n\
NGINX_CONF\n\
\n\
echo "✅ Nginx configuration generated"\n\
\n\
# Verifica che i file frontend esistano\n\
echo "Checking frontend files..."\n\
ls -la /usr/share/nginx/html/ || echo "Warning: Frontend files not found"\n\
test -f /usr/share/nginx/html/index.html && echo "✅ Frontend index.html found" || echo "❌ Frontend index.html missing"\n\
\n\
# Backend usa sempre porta fissa interna (non usa PORT di Railway)\n\
# Salviamo PORT originale di Railway per nginx\n\
ORIGINAL_PORT=$PORT\n\
# Forza backend a usare porta fissa\n\
export PORT=$BACKEND_PORT\n\
\n\
# Avvia backend in background\n\
echo "Starting backend on port $BACKEND_PORT (internal, Railway PORT=$ORIGINAL_PORT will be used by nginx)..."\n\
cd /app/backend\n\
node dist/src/main.js > /tmp/backend.log 2>&1 &\n\
BACKEND_PID=$!\n\
echo "Backend started with PID: $BACKEND_PID"\n\
\n\
# Attendi che il backend sia pronto\n\
echo "Waiting for backend to start and listen on port $BACKEND_PORT..."\n\
MAX_ATTEMPTS=60\n\
for i in $(seq 1 $MAX_ATTEMPTS); do\n\
  if nc -z 127.0.0.1 $BACKEND_PORT 2>/dev/null; then\n\
    echo "✅ Backend is listening on port $BACKEND_PORT (attempt $i)"\n\
    # Doppio check\n\
    sleep 2\n\
    if nc -z 127.0.0.1 $BACKEND_PORT 2>/dev/null; then\n\
      echo "✅ Backend health check passed"\n\
      break\n\
    fi\n\
  else\n\
    if [ $i -eq 1 ]; then\n\
      echo "Waiting for backend... (attempt $i/$MAX_ATTEMPTS)"\n\
    elif [ $((i % 10)) -eq 0 ]; then\n\
      echo "Still waiting for backend... (attempt $i/$MAX_ATTEMPTS)"\n\
      echo "Backend process status:"\n\
      ps aux | grep "[n]ode dist/src/main.js" || echo "Backend process not found!"\n\
      echo "Last 10 lines of backend log:"\n\
      tail -10 /tmp/backend.log 2>/dev/null || echo "No backend log available"\n\
    fi\n\
    if [ $i -eq $MAX_ATTEMPTS ]; then\n\
      echo "❌ Backend did not start after $MAX_ATTEMPTS seconds"\n\
      echo "Backend process status:"\n\
      ps aux | grep node\n\
      echo "Backend log:"\n\
      cat /tmp/backend.log 2>/dev/null || echo "No backend log"\n\
      exit 1\n\
    fi\n\
    sleep 1\n\
  fi\n\
done\n\
echo "✅ Backend is ready, starting nginx on port $NGINX_PORT..."\n\
\n\
# Avvia nginx in foreground\n\
echo "Starting nginx..."\n\
nginx -g "daemon off;" &\n\
NGINX_PID=$!\n\
\n\
echo "Both services started. Backend PID: $BACKEND_PID (port $BACKEND_PORT), Nginx PID: $NGINX_PID (port $NGINX_PORT)"\n\
\n\
# Attendi che entrambi i processi finiscano\n\
wait $BACKEND_PID $NGINX_PID\n\
' > /start.sh && chmod +x /start.sh

EXPOSE 80
# Nota: Railway userà la variabile d'ambiente PORT per esporre il servizio
# Nginx ascolterà su PORT (o 80 se non impostato)

CMD ["/start.sh"]

